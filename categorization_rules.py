import sys
import pandas as pd
import numpy as np
from bayesnet_node_info import get_observable_vars

def translate_to_category_previous(attr_val, attr_name, level=None):
    """
    These rules are for the previous dataset (SigCHI19 submission).
    """
    ranges = {
        "Angle": lambda x: 3 if x < 11.25 else 2 if 11.25 <= x < 33.75 else 1,
        "AssignmentComplete": lambda x: 3 if x == 1 else 1,
        "BuildingComplete": lambda x: 3 if x == 1 else 1,
        "Distance": lambda x: 3 if x < 5 else 2 if 5 <= x < 15 else 1,
        "LevelComplete": lambda x: 3 if x == 1 else 1,
        "MaterialsCredits": lambda x: 3 if x > 8000 else 2 if 2000 <= x <= 8000 else 1,
        "NumAssignments": lambda x: 3 if x <= 15 else 2 if 15 < x <= 22 else 1,
        "NumBlocks":
            {"43Stadium1": lambda x: 3 if 93.75 <= x < 106.25 else 2 if (106.25 <= x < 118.75) or (81.25 <= x < 93.75) else 1,
             "Stadium2": lambda x: 3 if 187.5 <= x < 212.5 else 2 if (212.5 <= x < 237.5) or (162.5 <= x < 187.5) else 1,
             "IslandBuild01": lambda x: 3 if x <= 5 else 1,
             "IslandBuild02": lambda x: 3 if x <= 5 else 1,
             "IslandBuild03": lambda x: 3 if x <= 5 else 1,
             "SchoolBuild": lambda x: 3 if x <= 5 else 1,
             "default": lambda x: 3 if x <= 5 else 1,
            },
        "NumFailedAssignments": lambda x: 3 if x <= 2 else 2 if 2 < x <= 4 else 1,
        "NumFamilyCollected": lambda x: 3 if x <= 2 else 2 if 2 < x <= 4 else 1,
        "NumTrades": lambda x: 3 if x <= 2 else 2 if 2 < x < 5 else 1,
        "NumWrong": lambda x: 3 if x <= 1 else 2 if 1 < x < 3 else 1,
        "Size": lambda x: 3 if x < 10 else 2 if 10 <= x < 20 else 1,
        "Time": lambda x: 3 if x < 200 else 2 if 200 <= x < 500 else 1,
        "TotalLost": lambda x: 3 if x > -10 else 2 if -150 <= x < -10 else 1,
        "pretest":
            {"pre_math": lambda x: 3 if x >= 54.2 else 2 if 22.8 <= x < 54.2 else 1,
             "pre_ratio": lambda x: 3 if x >= 69.4 else 2 if 31.8 <= x < 69.4 else 1,
             "pre_geom":lambda x: 3 if x >= 41.47 else 2 if 3.53 <= x < 41.47 else 1,
             "defaut": lambda x: 3 if x >= 66.7 else 2 if 33.3 <= x < 66.7 else 1
            },
        "posttest":
            {"post_math": lambda x: 3 if x >= 54.2 else 2 if 22.8 <= x < 54.2 else 1,
             "post_ratio": lambda x: 3 if x >= 69.4 else 2 if 31.8 <= x < 69.4 else 1,
             "post_geom":lambda x: 3 if x >= 41.47 else 2 if 3.53 <= x < 41.47 else 1,
             "defaut": lambda x: 3 if x >= 66.7 else 2 if 33.3 <= x < 66.7 else 1
            }
        }

    alpha_cat = {1: "Low", 2: "Medium", 3: "High"}

    try:
        cat = ranges[attr_name](attr_val)
    except:
        cat = ranges[attr_name][level](attr_val)

    return alpha_cat[cat]


def print_categorization_rules(data_csv, prepost_csv, out_py):
    """
    Categorization rule for each observable depends on its mean and
    standard deviation. This function takes a data csv file generated by
    game_xml_logs_to_csv.py and computes the statistics per observable per
    level.

    The rules are printed as a nested dictionary with the observable names
    as the first level keys and the gamelevel names as the second level keys.

    'out_py' is a Python module that will hold the thus printed dictionary.
    """
    out_fp = open(out_py, "w")

    df = pd.read_csv(data_csv, header=0)
    df_prepost = pd.read_csv(prepost_csv, header=0)

    observables = get_observable_vars()

    levels = df.game_level.unique().tolist()

    df_new = df.set_index("game_level")

    # Observables for which smaller values are better.
    obs_neg = ["Angle", "Time", "Distance"]

    # Binary observables don't need standard deviation/mean.
    obs_binary = ["AssignmentComplete", "LevelComplete", "BuildingComplete"]

    # Math score
    obs_math = ["math"]

    lvl_skip = [""]

    print("# Categorization of Harrell's class at Thomasville Middle School.", file=out_fp)
    print("TMS_CATEGORIZATION = ", end="", file=out_fp)

    print("{", file=out_fp)
    for obs in observables:
        print(f'"{obs}": {{', file=out_fp)
        for lvl in levels:
            # Training levels can be skipped?
            #if "Training" in lvl:
            #    continue

            data = df_new.loc[lvl][obs]
            if isinstance(data, pd.core.series.Series) and (not np.isnan(data.mean())) and data.any() and len(data) >= 3:
                avg = df_new.loc[lvl][obs].mean()
                std = df_new.loc[lvl][obs].std()
                upper = avg + std
                lower = avg - std

                if obs in obs_neg:
                    print(f'    "{lvl}": lambda x: "High" if x < {lower:.2f} else "Medium" if {lower:.2f} <= x < {upper:.2f} else "Low",', file=out_fp)
                elif obs in obs_binary:
                    print(f'    "{lvl}": lambda x: "High" if x == 1 else "Low",', file=out_fp)
                else:
                    print(f'    "{lvl}": lambda x: "High" if x >= {upper:.2f} else "Medium" if {lower:.2f} <= x < {upper:.2f} else "Low",', file=out_fp)
                #print(obs, lvl, df_new.loc[lvl][obs].shape, df_new.loc[lvl][obs].mean(), df_new.loc[lvl][obs].std())

        print('},', file=out_fp)

    # Rule for the chronologically adjusted math score is computed from the
    # premath scores.
    math_avg = df_prepost["premath"].mean()
    math_std = df_prepost["premath"].std()
    math_upper = math_avg + math_std
    math_lower = math_avg - math_std
    print(f'"math": lambda x: "High" if x >= {math_upper:.2f} else "Medium" if {math_lower:.2f} <= x < {math_upper:.2f} else "Low"', file=out_fp)

    print("}", file=out_fp)


def extract_categorization_rules():
    # CSV file containing game observables + others
    data_csv = sys.argv[1]

    # CSV file containing only the prepost scores
    prepost_csv = sys.argv[2]

    # Output .py file where the categorization rules are printed out to.
    out_py_module = sys.argv[3]

    print_categorization_rules(data_csv, prepost_csv, out_py_module)


if __name__ == "__main__":
    extract_categorization_rules()
